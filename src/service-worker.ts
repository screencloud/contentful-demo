/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */
/* eslint-disable @typescript-eslint/no-use-before-define */
// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.
import {
  clientsClaim,
  CachedResponseWillBeUsedCallbackParam,
  registerQuotaErrorCallback,
  HandlerDidCompleteCallbackParam,
} from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import {
  CacheFirst,
  NetworkOnly,
  StaleWhileRevalidate,
} from "workbox-strategies";
import { WorkboxPlugin } from "workbox-core";
import { CacheableResponsePlugin } from "workbox-cacheable-response";
import { setCacheNameDetails } from "workbox-core";
import { CacheExpiration } from "workbox-expiration";

declare const self: ServiceWorkerGlobalScope;

clientsClaim();
// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

self.addEventListener("install", (event: ExtendableEvent) => {
  // Installing a new service worker
  console.log("SW - install", event);
});

self.addEventListener("activate", (event) => {
  // Activating the new service worker
  console.log("SW - activate", event);

  const clearGoogleFontsStylesheetsCache = async () => {
    await Promise.all([
      await caches
        .open(mkCacheName("google-fonts-stylesheets"))
        .then((cache) => {
          cache.keys().then(async (keys) => {
            const cacheItemPromises = keys.map((key) => cache.delete(key));
            return await Promise.all(cacheItemPromises);
          });
        }),
      await caches.open(mkCacheName("custom-assets")).then((cache) => {
        cache.keys().then(async (keys) => {
          const cacheItemPromises = keys.map((key) => cache.delete(key));
          return await Promise.all(cacheItemPromises);
        });
      }),
    ]);
  };
  clearGoogleFontsStylesheetsCache();
});

const daysInSeconds = (numberOfDays: number): number =>
  numberOfDays * 24 * 60 * 60;

const cachePrefix = "app"; // the app caches use this prefix to be able to remove old caches easier

setCacheNameDetails({
  prefix: cachePrefix,
});

// precache methods honor setCacheNameDetails.prefix but strategies do not
// so we are using this function to set their cache name
const mkCacheName = (name: string): string => `${cachePrefix}-${name}`;

const expirationManager = new CacheExpiration(mkCacheName("images"), {
  maxEntries: 250, //employs LRU
  maxAgeSeconds: daysInSeconds(14),
  matchOptions: {
    ignoreVary: true,
  },
});

let hasQuotaError = false;

// Subscribe to quota error from workbox and log to datadog
registerQuotaErrorCallback(async () => {
  // Check if there is a Quota Error already in progress
  // This could happen when multiple instances are displayed/loading in different zones
  if (!hasQuotaError) {
    hasQuotaError = true;

    const cacheKeys = await self.caches.keys();
    const cacheKeysToDelete = cacheKeys.filter((key) =>
      key.includes(`${cachePrefix}-`)
    );

    const cacheMap: { [key: string]: number } = {};

    await Promise.all(
      cacheKeysToDelete.map(async (cacheKey) => {
        await caches.open(cacheKey).then((cache) => {
          cache.keys().then(async (keys) => {
            cacheMap[cacheKey] = keys.length;
            const cacheItemPromises = keys.map((key) => cache.delete(key));
            return await Promise.all(cacheItemPromises);
          });
        });
      })
    );

    hasQuotaError = false;
  }
});

class CachePlugin implements WorkboxPlugin {
  // Update the timestampe on the item that was accessed so that it will extend its life in the cache
  cachedResponseWillBeUsed(
    param: CachedResponseWillBeUsedCallbackParam
  ): Promise<Response | void | null | undefined> {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve) => {
      await expirationManager.updateTimestamp(param.request.url);
      resolve(param.cachedResponse);
    });
  }

  // Remove all items in the cache which have expired if the handler is used that is associated with the cache
  handlerDidComplete(
    param: HandlerDidCompleteCallbackParam
  ): Promise<void | null | undefined> {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve) => {
      await expirationManager.expireEntries();
      resolve(undefined);
    });
  }
}

// 1. Page Assets Handler
// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== "navigate") {
      return false;
    }
    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith("/_")) {
      return false;
    }
    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
);

// Image & Imgix Handler
registerRoute(
  ({ url, request }) => {
    return (
      request.destination === "image" ||
      // match https://<any subdomain>.imgix.net
      url.href.match(/^https:\/\/[-\w]+\.imgix\.net/)
    );
  },
  new CacheFirst({
    // Use a custom cache name.
    cacheName: mkCacheName("images"),
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new CachePlugin(),
    ],
  })
);

// Google Fonts Stylesheet
// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy since stylesheets can change frequently
// Always comes back as an opaque response
registerRoute(
  /^https:\/\/fonts\.googleapis\.com/,
  new StaleWhileRevalidate({
    cacheName: mkCacheName("google-fonts-stylesheets"),
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: daysInSeconds(21),
      }),
    ],
  })
);

// Google Fonts Webfonts
// Seems to always be CORS response due to crossOrigin set on link tag
// Disabled CORS on localhost - font files will show as Opaque responses
// When caching Opaue responses you will see an increase in cache storage different on each browser
// https://developer.chrome.com/docs/devtools/progressive-web-apps/#opaque-responses
registerRoute(
  /^https:\/\/fonts\.gstatic\.com/,
  new StaleWhileRevalidate({
    cacheName: mkCacheName("google-fonts-webfonts"),
    plugins: [
      new CacheableResponsePlugin({
        statuses: [200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: daysInSeconds(21),
      }),
    ],
  })
);

// Custom stylesheets and fonts for users adding custom fonts which are not hosted by Google
// https://medium.com/dev-channel/service-worker-caching-strategies-based-on-request-types-57411dd7652c
registerRoute(
  ({ request }) =>
    request.destination === "style" || request.destination === "font",
  new StaleWhileRevalidate({
    cacheName: mkCacheName("custom-assets"),
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200], // Status code 0 is used for opaque responses.
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: daysInSeconds(21),
      }),
    ],
  })
);

// Everything else (except service-worker.js & manifest.json)
registerRoute(({ url }) => {
  return (
    !url.pathname.includes("service-worker.js") &&
    !url.pathname.includes("manifest.json")
  );
}, new NetworkOnly());
